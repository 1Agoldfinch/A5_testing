# Assignment 5: Markdown and Software Libraries

## Report - Use Case 1
Finding an appropriate approach to solve this use case was quite simple. I started my research in chapter 11 of our official module materials and took a short look at table 11.1 again:
Here I immediately recognized that the correct package required for this case had to be **,,Shapely"** because the task implies the ,,analysis of some geometric objects in a non-specific cartesian coordinate system''(WKT-format!!!). Theoretically, this task could also be solved with ,,Geopandas'' (library) but the script-implementation would be a bit more complicated because ,,Geopandas'' mainly focuses on geospatial data whereas ,,Shapely'' exclusively addresses the processing of ,,spatially unbound'' geometries. For this reason ,,Shapely'' is the best choice for this case.

**In our case we had to determine the distance between the centroids of two polygons, whose coordinates are displayed in WKT-format. Therefore I identified the following steps necessary to complete the task by navigating through the official documentation site for Shapely 2.1.1.** 

**Please click the added links for further information/ documentation about the specific methods and objects mentioned here:**

1. <strong>loading the data from the WKT-strings and generating the geometries correctly</strong> 

   > **module shapely.wkt -> [,,`loads`''-function](https://shapely.readthedocs.io/en/latest/manual.html#shapely.wkt.loads)**   
   > **module shapely.geometry -> [,,`Polygon`''-class](https://shapely.readthedocs.io/en/stable/reference/shapely.Polygon.html#shapely.Polygon)**

2. <strong>determining the centroids of the geometries</strong>
   > **[,,`.centroid`''-attribute](https://shapely.readthedocs.io/en/latest/manual.html#object.centroid)**

3. <strong>calculating the distances between them</strong>
   > **[,,`.distance()`''-method](https://shapely.readthedocs.io/en/latest/manual.html#object.distance)**

### Script (Python):

```
{
from shapely.wkt import loads # Importing the loads-function from the shapely.wkt-module
from shapely.geometry import Polygon # Importing the polygon-class in order to create our desired polygon afterwards

# Determining the WKT-strings of our polygons
WKT_polygon1 = "POLYGON ((4.2 0, 1.3 4, -3.4 2.47, -3.4 -2.47, 1.3 -4, 4.2 0))"
WKT_polygon2 = "POLYGON ((46.2 0, 43.3 4, 38.6 2.47, 38.6 -2.47, 43.3 -4, 46.2 0))"

# Generating/ Loading the polygon-geometries out of our WKT-strings (,,loads''-function)
polygon1 = loads(WKT_polygon1)
polygon2 = loads(WKT_polygon2)

# Calculate the centroids of the polygons (,,.centroid''-attribute)
centroid1 = polygon1.centroid
centroid2 = polygon2.centroid

# Calculate the distance between the two centroids (,,.distance()''-method)
distance = centroid1.distance(centroid2)

print(f"The distance between the two centroids is: {distance}")
}
```

- **Python Version used: Python 3.12.11**
- **Package Version used: Shapely 2.1.1**


## Report - Use Case 2
The aim of this exercise was to find an efficient way to transfer the coordinates of a point into another reference coordinate system. In detail, we had to transfer the point's coordinates given in WKT-format ("POINT (114.17208 22.29345)") from EPSG:4326 (WGS84) to EPSG:2326 (HK80). Due to this fact and unlike in the first use case it is obvious that we have to use a library intended for the processing of geospatial data now. During my research I identified **,,GeoPandas''** as the library most suitable for this task although this case could theoretically also be completed with other options (like ,,Arcpy'' or ,,PyQGIS''). But I will go into that in more detail later.

**In the end I chose ,,GeoPandas'' and started to research on the official documentary-site for GeoPandas Version 1.1.1. The following steps are necessary to complete this use case (Again, please click the links for further information about the methods and objects used!):**

1. <strong>creating a GeoDataFrame and loading the point into it (based on the WKT-strings(EPSG:4326))</strong> 

   > **library geopandas -> [,,`GeoDataFrame`''-class](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.html#geopandas.GeoDataFrame)**  
   > **module shapely.wkt -> [,,`loads`''-function](https://shapely.readthedocs.io/en/latest/#)**

2. <strong>transforming our point into EPSG:2326</strong>
   > **[,,`.to_crs()`''-method](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_crs.html#geopandas.GeoDataFrame.to_crs)**

### Script (Python):

```
{
import geopandas as gpd # import of the geopandas-library (alias ,,gpd'')
from shapely.wkt import loads # loads-function from the shapely.wkt-module; needed again to load our point into the GeoDataFrame

# Determining the WKT-String of our point
wkt_point = "POINT (114.17208 22.29345)"

# Creation of a so-called ,,GeoDataFrame'' in order to load our point (in EPSG:4326);
# A ,,GeoDataFrame'' is a tabel used for loading and saving geospacial data like ,,geographic''-points or locations in our case
gdf = gpd.GeoDataFrame(geometry=[loads(wkt_point)], crs="EPSG:4326") # ,,loads''-function

# Transformation of our point into EPSG:2326
gdf = gdf.to_crs("EPSG:2326") # ,,.to_crs()''-method

print(gdf.geometry)
}
```

#### About the other options
As mentioned in the beginning, completing this use case would also be possible by using the packages ,,Arypy'' or ,,PyQGIS''. Technically both ways would offer the same final result as ,,GeoPandas'' does but the problem lies in their specific ,,ease of use''. Generally both packages are intended to be used for more complex GIS-related tasks. This means that ,,Arcpy''- or ,,PyQGIS''-users have to write a ,,little' more complicated syntax in order to ,,make ends meet''. For our example (task):

- When using ,,Arcpy'' one has to create a point-object as well as its geometry-object separately whereas this is not necessary when using ,,GeoPandas''. Here the shorter ,,loading of the point into the GeoDataFrame'' fullfills the same functionality.

- When using ,,PyQGIS'' both coordinate systems have to be determined within two different cells (QgsCoordinateReferenceSystem-classes) whereas those can easily be inserted directly into our functions and methods while using ,,GeoPandas''. Therefore solving this case with ,,GeoPandas'' requiers less cells (code) on the one hand and is much easier to understand for beginners (and non-GIS-initiated ones) as well.




- **Python Version used: Python 3.12.11**                                                                               
- **Library Versions used: GeoPandas 1.1.1**



## Report - Use Case 3
Here, we had to write a script which is able to download a GeoJSON-file from an online-source (URL provided) and filters all airports located in the canadian province of Nova Scotia. Afterwards the filtered data of the GeoJSON should be saved within a .csv-file on my local machine as well. Furthermore it was not allowed to modify the ,,where''-clause of the URL given to us. Since this use case not only required just the reading of a GeoJSON-file but as well it's efficient analysis (filtering) I prefered **,,GeoPandas''** again. Unlike ,,Fiona'', ,,GeoPandas'' extends the data science-library ,,Pandas'' by adding additional support for geospatial data, which enables a broader range of analytic uses (including filtering geospatial data). Moreover, the implementation of the download rewuired the **,,Requests''**-library in particular.

**After my research on the official documentary-site of GeoPandas 1.1.1 as well as on the educational portal ,,GeeksforGeeks''and others, I was able to identify the following steps in order to complete this use case (links added for further information/ documentary):**

1. <strong>downloading the GeoJSON from the URL and saving it on the local machine</strong> 

   > **requests.get(url) -> [,,`.get()`''-function](https://requests.readthedocs.io/en/latest/user/quickstart/)**   
   > **with open("data.geojson", "wb") as f -> [,,`open(file, mode)`''-function](https://www.geeksforgeeks.org/python/file-mode-in-python/)**   
   > **f.write(response.content) -> [,,`f.write(data)`''-method/ ,,`.content`''-attribute](https://www.geeksforgeeks.org/python/response-content-python-requests/)**   

2. <strong>reading the content of the GeoJSON and filtering the airports</strong>
   > **gpd.read_file("data.geojson") -> [,,`.read_file()`''-function](https://geopandas.org/en/stable/docs/reference/api/geopandas.read_file.html#geopandas.read_file)**   
   > **gdf[gdf['PROVINCE'] == 'Nova Scotia'] -> [,,`filtering`''-option](https://www.geeksforgeeks.org/pandas/ways-to-filter-pandas-dataframe-by-column-values/)**

3. <strong>saving the results as .csv-file</strong>
   > **filtered_gdf.to_csv("filtered_buildings.csv") -> [,,`.to_csv()`''-method](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.html)**

### Script (Python):

```
{
import requests # import of the ,,requests''-library
import geopandas as gpd # import of the geopandas-library (alias ,,gpd'')

# Downloading the GeoJSON
url = "https://maps-cartes.services.geo.ca/server_serveur/rest/services/TC/canadian_airports_w_air_navigation_services_en/MapServer/0/query?outFields=*&where=1=1&f=geojson"
response = requests.get(url) # ,,.get()''-function (Requests)

# Saving the file on our local machine 
with open("data.geojson", "wb") as f: # ,,open(file, mode)''-function (Standard Python)
    f.write(response.content) # ,,f.write(data)''-method; ,,.content''-attribute (Standard Python)

# Reading the content of the GeoJSON
gdf = gpd.read_file("data.geojson") # ,,.read_file()''-function (GeoPandas)

# Filtering of all airports located in Nova Scotia
filtered_gdf = gdf[gdf['PROVINCE'] == 'Nova Scotia']  # Specific filtering-option (GeoPandas)

# Saving of the filtered results locally as .csv-file
filtered_gdf.to_csv("filtered_buildings.csv") # ,,.to_csv()''-method (Geopandas)
}
```

#### Possible alternative
Hypothetically, this case could also be solved by using the **,,Pandas''-** and **,,Fiona''-** libraries combined, but this way has some disadvantages:
First, the user has to import an additional library AND the reading of the GeoJSON's content requires more code than it would be the case with ,,GeoPnadas'' alone. While the user has to open the GeoJSON with Fiona first and then has to convert the faetures into a Pandas-DataFrame in order to read the content, the user only needs a single line (,,.read_file()''-function) to do the same with Geopandas (Required Lines of Code for this; Geopandas vs. Pandas&Fiona: 1/4).
Furthermore the original way does not require to convert the features into a DataFrame first in order to filter and save the data laterwards but only requires a single ,,specific filtering option'' and ,,to_csv()''-method instead.



- **Python Version used: Python 3.12.11** 
- **Library Versions used: GeoPandas 1.1.1/ Requests 2.32.4**



## Report - Use Case 4
For this use case we had to write a script which performs ,,reverse geocoding'' on the point given in use case 2. This means that our script has to determine the exact address or place-name for this coordinates/ location. I considered the library named **,,Geopy''** as the best choice for this task since ,,Geopy'' also includes the functionalities of the geocoding software **,,Nominatim''**. Beside beeing used for ,,ordinary'' geocoding, this software is able to perform ,,reverse geocoding'' as well and allocates addresses to specific coordinates by using the data of ,,OpenStreetMap''. I became aware of this through the info provided for this UNIGIS-module (geopy/test/geocoders/nominatim.py). Furthermore the ,,loads''-function of ,,Shapely'' was required for this case again, in order to transform the coordinates into a geometry.

**While doing my research on the official documentary page of ,,Geopy'', I spotted out the following steps necessary to be done (links added again):**

1. <strong>determining the point's coordinates and loading them into a geometry</strong> 

   > **point = loads(wkt_point) -> [,,`loads`''-function](https://shapely.readthedocs.io/en/latest/manual.html#shapely.wkt.loads)**   
    

2. <strong>initialisation of the (,,reverse''-) geocoder used</strong>
   > **geolocator = Nominatim(user_agent="myGeocoderApp") -> [,,`Nominatim`''-class](https://geopy.readthedocs.io/en/latest/index.html?highlight=nominatim#geopy.geocoders.Nominatim)**   
   

3. <strong>executing the reverse geocoding and printing the result</strong>
   > **geolocator.reverse((point.y, point.x)) -> [,,`.reverse((latitude/longitude))`''-method](https://geopy.readthedocs.io/en/latest/index.html?highlight=reverse#geopy.geocoders.Nominatim.reverse)**   
   > **print(location.address) -> [,,`.address`''-attribute](https://geopy.readthedocs.io/en/stable/)**


### Script (Python):

```
{
from geopy.geocoders import Nominatim # ,,Nominatim''-class which sends requests to the ,,Nominatim''-server
from shapely.wkt import loads # Importing the loads-function from the shapely.wkt-module; needed for line 6

# Determining the point (wkt-format) and creating it's geometry
wkt_point = "POINT (114.17208 22.29345)"
point = loads(wkt_point) # ,,loads''-function (Shapely); transforming the wkt-coordinates into a geometry

# Initialising the geocoder used (Nominatim)
geolocator = Nominatim(user_agent="myGeocoderApp") # ,,Nominatim''-class (Geopy); a valid user_agent has to be determined or the ,,Nominatim''-Server may reject the request

# Executing reverse geocoding
location = geolocator.reverse((point.y, point.x)) # ,,.reverse((latitude/longitude))''-method (Geopy); Please mind the correct order (latitude/ longitude)!!!

# printing the final address of the point
if location:
    print(location.address) # ,,address''-attribute (Geopy)
else:
    print("No address identified.")
}
```

#### Possible alternative
During my futher research laterwards, I discovered an alternative way for completing this task. This solution is even easier to implement, especially for beginners, than the approach via ,,Geopy'' explained before. The implementation of the script for use case 4 can also be completed with the use of the **,,Geocoder''**-library:

While one has to create an extra ,,Nominatim''-class AND the ,,.reverse((latitude/longitude))-method in order to ,,get'' the address of the point with ,,Geopy'', the same process can be managed with a single **,,osm''-function** while using the ,,Geocoder''-library. Additionally, the user do not has to transform the wkt-coordinates into a geometry (point object) before when using ,,Geocoder''. Creating a short list containing the coordinates is completely sufficient in this case. All these factors allow the user to create a shorter script with ,,Geocoder'' which does not require all the functions, classes and methodes which would be necessary for writing the script with ,,Geopy''. Therefore the clear advantage of using ,,Geocoder'' lies in the simpler structure of the code required and the absence of some components that may be confusing for inexperienced users (,,Nominatim''-class!!!/ ,,.reverse()''-method!!!).



##### Alternative Script (Python)

```
{
import geocoder  # Importing the Geocoder library

# Listing the point coordinates
latitude = 22.29345
longitude = 114.17208

# Executing reverse geocoding
g = geocoder.osm([latitude, longitude], method='reverse') # ,,.osm()''-function with incorporated ,,method='reverse'-parameter''

# Printing the final address of the point
if g.ok:
    print(g.address)  # Accessing the address if found
else:
    print("No address identified.")
}
```



- **Python Version used: Python 3.12.11**                                                                               
- **Library Versions used: Geopy 2.4.1/ Shapely 2.1.1/ Geocoder 1.38.1**